{"ast":null,"code":"import * as cborg from 'cborg';\nimport { CID } from 'multiformats/cid';\nconst CID_CBOR_TAG = 42;\n\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n\n  const cid = CID.asCID(obj);\n\n  if (!cid) {\n    return null;\n  }\n\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1);\n  return [new cborg.Token(cborg.Type.tag, CID_CBOR_TAG), new cborg.Token(cborg.Type.bytes, bytes)];\n}\n\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\n\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  return null;\n}\n\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\n\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n\n  return CID.decode(bytes.subarray(1));\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nexport const name = 'dag-cbor';\nexport const code = 113;\nexport const encode = node => cborg.encode(node, encodeOptions);\nexport const decode = data => cborg.decode(data, decodeOptions);","map":{"version":3,"names":["cborg","CID","CID_CBOR_TAG","cidEncoder","obj","asCID","cid","bytes","Uint8Array","byteLength","set","Token","Type","tag","undefinedEncoder","Error","numberEncoder","num","Number","isNaN","Infinity","encodeOptions","float64","typeEncoders","Object","undefined","number","cidDecoder","decode","subarray","decodeOptions","allowIndefinite","coerceUndefinedToNull","allowNaN","allowInfinity","allowBigInt","strict","useMaps","tags","name","code","encode","node","data"],"sources":["C:/Users/Ritika Mahajan/.vscode/Blockchain_Project/NFT-Marketplace/node_modules/@ipld/dag-cbor/esm/index.js"],"sourcesContent":["import * as cborg from 'cborg';\r\nimport { CID } from 'multiformats/cid';\r\nconst CID_CBOR_TAG = 42;\r\nfunction cidEncoder(obj) {\r\n  if (obj.asCID !== obj) {\r\n    return null;\r\n  }\r\n  const cid = CID.asCID(obj);\r\n  if (!cid) {\r\n    return null;\r\n  }\r\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\r\n  bytes.set(cid.bytes, 1);\r\n  return [\r\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\r\n    new cborg.Token(cborg.Type.bytes, bytes)\r\n  ];\r\n}\r\nfunction undefinedEncoder() {\r\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\r\n}\r\nfunction numberEncoder(num) {\r\n  if (Number.isNaN(num)) {\r\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\r\n  }\r\n  if (num === Infinity || num === -Infinity) {\r\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\r\n  }\r\n  return null;\r\n}\r\nconst encodeOptions = {\r\n  float64: true,\r\n  typeEncoders: {\r\n    Object: cidEncoder,\r\n    undefined: undefinedEncoder,\r\n    number: numberEncoder\r\n  }\r\n};\r\nfunction cidDecoder(bytes) {\r\n  if (bytes[0] !== 0) {\r\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\r\n  }\r\n  return CID.decode(bytes.subarray(1));\r\n}\r\nconst decodeOptions = {\r\n  allowIndefinite: false,\r\n  coerceUndefinedToNull: true,\r\n  allowNaN: false,\r\n  allowInfinity: false,\r\n  allowBigInt: true,\r\n  strict: true,\r\n  useMaps: false,\r\n  tags: []\r\n};\r\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\r\nexport const name = 'dag-cbor';\r\nexport const code = 113;\r\nexport const encode = node => cborg.encode(node, encodeOptions);\r\nexport const decode = data => cborg.decode(data, decodeOptions);"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA,MAAMC,YAAY,GAAG,EAArB;;AACA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;EACvB,IAAIA,GAAG,CAACC,KAAJ,KAAcD,GAAlB,EAAuB;IACrB,OAAO,IAAP;EACD;;EACD,MAAME,GAAG,GAAGL,GAAG,CAACI,KAAJ,CAAUD,GAAV,CAAZ;;EACA,IAAI,CAACE,GAAL,EAAU;IACR,OAAO,IAAP;EACD;;EACD,MAAMC,KAAK,GAAG,IAAIC,UAAJ,CAAeF,GAAG,CAACC,KAAJ,CAAUE,UAAV,GAAuB,CAAtC,CAAd;EACAF,KAAK,CAACG,GAAN,CAAUJ,GAAG,CAACC,KAAd,EAAqB,CAArB;EACA,OAAO,CACL,IAAIP,KAAK,CAACW,KAAV,CAAgBX,KAAK,CAACY,IAAN,CAAWC,GAA3B,EAAgCX,YAAhC,CADK,EAEL,IAAIF,KAAK,CAACW,KAAV,CAAgBX,KAAK,CAACY,IAAN,CAAWL,KAA3B,EAAkCA,KAAlC,CAFK,CAAP;AAID;;AACD,SAASO,gBAAT,GAA4B;EAC1B,MAAM,IAAIC,KAAJ,CAAU,2EAAV,CAAN;AACD;;AACD,SAASC,aAAT,CAAuBC,GAAvB,EAA4B;EAC1B,IAAIC,MAAM,CAACC,KAAP,CAAaF,GAAb,CAAJ,EAAuB;IACrB,MAAM,IAAIF,KAAJ,CAAU,qEAAV,CAAN;EACD;;EACD,IAAIE,GAAG,KAAKG,QAAR,IAAoBH,GAAG,KAAK,CAACG,QAAjC,EAA2C;IACzC,MAAM,IAAIL,KAAJ,CAAU,0FAAV,CAAN;EACD;;EACD,OAAO,IAAP;AACD;;AACD,MAAMM,aAAa,GAAG;EACpBC,OAAO,EAAE,IADW;EAEpBC,YAAY,EAAE;IACZC,MAAM,EAAErB,UADI;IAEZsB,SAAS,EAAEX,gBAFC;IAGZY,MAAM,EAAEV;EAHI;AAFM,CAAtB;;AAQA,SAASW,UAAT,CAAoBpB,KAApB,EAA2B;EACzB,IAAIA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAjB,EAAoB;IAClB,MAAM,IAAIQ,KAAJ,CAAU,oDAAV,CAAN;EACD;;EACD,OAAOd,GAAG,CAAC2B,MAAJ,CAAWrB,KAAK,CAACsB,QAAN,CAAe,CAAf,CAAX,CAAP;AACD;;AACD,MAAMC,aAAa,GAAG;EACpBC,eAAe,EAAE,KADG;EAEpBC,qBAAqB,EAAE,IAFH;EAGpBC,QAAQ,EAAE,KAHU;EAIpBC,aAAa,EAAE,KAJK;EAKpBC,WAAW,EAAE,IALO;EAMpBC,MAAM,EAAE,IANY;EAOpBC,OAAO,EAAE,KAPW;EAQpBC,IAAI,EAAE;AARc,CAAtB;AAUAR,aAAa,CAACQ,IAAd,CAAmBpC,YAAnB,IAAmCyB,UAAnC;AACA,OAAO,MAAMY,IAAI,GAAG,UAAb;AACP,OAAO,MAAMC,IAAI,GAAG,GAAb;AACP,OAAO,MAAMC,MAAM,GAAGC,IAAI,IAAI1C,KAAK,CAACyC,MAAN,CAAaC,IAAb,EAAmBrB,aAAnB,CAAvB;AACP,OAAO,MAAMO,MAAM,GAAGe,IAAI,IAAI3C,KAAK,CAAC4B,MAAN,CAAae,IAAb,EAAmBb,aAAnB,CAAvB"},"metadata":{},"sourceType":"module"}