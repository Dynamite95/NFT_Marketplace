{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"./utils\");\n\nconst cid_1 = require(\"multiformats/cid\");\n\nfunction fromSplit(split) {\n  const [protectedHeader, payload, signature] = split;\n  return {\n    payload,\n    signatures: [{\n      protected: protectedHeader,\n      signature\n    }],\n    link: cid_1.CID.decode(utils_1.fromBase64url(payload))\n  };\n}\n\nfunction encodeSignature(signature) {\n  const encoded = {\n    signature: utils_1.fromBase64url(signature.signature)\n  };\n  if (signature.header) encoded.header = signature.header;\n  if (signature.protected) encoded.protected = utils_1.fromBase64url(signature.protected);\n  return encoded;\n}\n\nfunction encode(jws) {\n  const payload = utils_1.fromBase64url(jws.payload);\n\n  try {\n    cid_1.CID.decode(payload);\n  } catch (e) {\n    throw new Error('Not a valid DagJWS');\n  }\n\n  const encodedJws = {\n    payload,\n    signatures: jws.signatures.map(encodeSignature)\n  };\n  return encodedJws;\n}\n\nfunction decodeSignature(encoded) {\n  const sign = {\n    signature: utils_1.toBase64url(encoded.signature)\n  };\n  if (encoded.header) sign.header = encoded.header;\n  if (encoded.protected) sign.protected = utils_1.toBase64url(encoded.protected);\n  return sign;\n}\n\nfunction decode(encoded) {\n  const decoded = {\n    payload: utils_1.toBase64url(encoded.payload),\n    signatures: encoded.signatures.map(decodeSignature)\n  };\n  decoded.link = cid_1.CID.decode(new Uint8Array(encoded.payload));\n  return decoded;\n}\n\nexports.default = {\n  fromSplit,\n  encode,\n  decode\n};","map":{"version":3,"mappings":";;;;;;AAAA;;AACA;;AAiCA,SAASA,SAAT,CAAmBC,KAAnB,EAAuC;EACrC,MAAM,CAACC,eAAD,EAAkBC,OAAlB,EAA2BC,SAA3B,IAAwCH,KAA9C;EACA,OAAO;IACLE,OADK;IAELE,UAAU,EAAE,CAAC;MAAEC,SAAS,EAAEJ,eAAb;MAA8BE;IAA9B,CAAD,CAFP;IAGLG,IAAI,EAAEC,UAAIC,MAAJ,CAAWC,sBAAcP,OAAd,CAAX;EAHD,CAAP;AAKD;;AAED,SAASQ,eAAT,CAAyBP,SAAzB,EAAgD;EAC9C,MAAMQ,OAAO,GAAqB;IAChCR,SAAS,EAAEM,sBAAcN,SAAS,CAACA,SAAxB;EADqB,CAAlC;EAGA,IAAIA,SAAS,CAACS,MAAd,EAAsBD,OAAO,CAACC,MAAR,GAAiBT,SAAS,CAACS,MAA3B;EACtB,IAAIT,SAAS,CAACE,SAAd,EAAyBM,OAAO,CAACN,SAAR,GAAoBI,sBAAcN,SAAS,CAACE,SAAxB,CAApB;EACzB,OAAOM,OAAP;AACD;;AAED,SAASE,MAAT,CAAgBC,GAAhB,EAA2B;EACzB,MAAMZ,OAAO,GAAGO,sBAAcK,GAAG,CAACZ,OAAlB,CAAhB;;EACA,IAAI;IACFK,UAAIC,MAAJ,CAAWN,OAAX;EACD,CAFD,CAEE,OAAOa,CAAP,EAAU;IACV,MAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;EACD;;EACD,MAAMC,UAAU,GAAe;IAC7Bf,OAD6B;IAE7BE,UAAU,EAAEU,GAAG,CAACV,UAAJ,CAAec,GAAf,CAAmBR,eAAnB;EAFiB,CAA/B;EAIA,OAAOO,UAAP;AACD;;AAED,SAASE,eAAT,CAAyBR,OAAzB,EAAkD;EAChD,MAAMS,IAAI,GAAiB;IACzBjB,SAAS,EAAEM,oBAAYE,OAAO,CAACR,SAApB;EADc,CAA3B;EAGA,IAAIQ,OAAO,CAACC,MAAZ,EAAoBQ,IAAI,CAACR,MAAL,GAAcD,OAAO,CAACC,MAAtB;EACpB,IAAID,OAAO,CAACN,SAAZ,EAAuBe,IAAI,CAACf,SAAL,GAAiBI,oBAAYE,OAAO,CAACN,SAApB,CAAjB;EACvB,OAAOe,IAAP;AACD;;AAED,SAASZ,MAAT,CAAgBG,OAAhB,EAAmC;EACjC,MAAMU,OAAO,GAAW;IACtBnB,OAAO,EAAEO,oBAAYE,OAAO,CAACT,OAApB,CADa;IAEtBE,UAAU,EAAEO,OAAO,CAACP,UAAR,CAAmBc,GAAnB,CAAuBC,eAAvB;EAFU,CAAxB;EAIAE,OAAO,CAACf,IAAR,GAAeC,UAAIC,MAAJ,CAAW,IAAIc,UAAJ,CAAeX,OAAO,CAACT,OAAvB,CAAX,CAAf;EACA,OAAOmB,OAAP;AACD;;AAEDE,kBAAe;EACbxB,SADa;EAEbc,MAFa;EAGbL;AAHa,CAAf","names":["fromSplit","split","protectedHeader","payload","signature","signatures","protected","link","cid_1","decode","utils_1","encodeSignature","encoded","header","encode","jws","e","Error","encodedJws","map","decodeSignature","sign","decoded","Uint8Array","exports"],"sources":["C:\\Users\\Ritika Mahajan\\.vscode\\Blockchain_Project\\NFT-Marketplace\\node_modules\\dag-jose\\src\\signing.ts"],"sourcesContent":["import { fromBase64url, toBase64url } from './utils'\r\nimport { CID } from 'multiformats/cid'\r\n\r\ninterface JWSSignature {\r\n  header?: Record<string, any>\r\n  protected?: string\r\n  signature: string\r\n}\r\n\r\nexport interface DagJWS {\r\n  payload: string\r\n  signatures: Array<JWSSignature>\r\n  link?: CID\r\n}\r\n\r\ninterface EncodedSignature {\r\n  header?: Record<string, any>\r\n  protected?: Uint8Array\r\n  signature: Uint8Array\r\n}\r\n\r\nexport interface EncodedJWS {\r\n  payload: Uint8Array\r\n  signatures: Array<EncodedSignature>\r\n}\r\n\r\nexport interface PublicKey {\r\n  id: string\r\n  type: string\r\n  controller: string\r\n  publicKeyHex?: string\r\n  publicKeyBase64?: string\r\n}\r\n\r\nfunction fromSplit(split: Array<string>): DagJWS {\r\n  const [protectedHeader, payload, signature] = split\r\n  return {\r\n    payload,\r\n    signatures: [{ protected: protectedHeader, signature }],\r\n    link: CID.decode(fromBase64url(payload)),\r\n  }\r\n}\r\n\r\nfunction encodeSignature(signature: JWSSignature): EncodedSignature {\r\n  const encoded: EncodedSignature = {\r\n    signature: fromBase64url(signature.signature),\r\n  }\r\n  if (signature.header) encoded.header = signature.header\r\n  if (signature.protected) encoded.protected = fromBase64url(signature.protected)\r\n  return encoded\r\n}\r\n\r\nfunction encode(jws: DagJWS): EncodedJWS {\r\n  const payload = fromBase64url(jws.payload)\r\n  try {\r\n    CID.decode(payload)\r\n  } catch (e) {\r\n    throw new Error('Not a valid DagJWS')\r\n  }\r\n  const encodedJws: EncodedJWS = {\r\n    payload,\r\n    signatures: jws.signatures.map(encodeSignature),\r\n  }\r\n  return encodedJws\r\n}\r\n\r\nfunction decodeSignature(encoded: EncodedSignature): JWSSignature {\r\n  const sign: JWSSignature = {\r\n    signature: toBase64url(encoded.signature),\r\n  }\r\n  if (encoded.header) sign.header = encoded.header\r\n  if (encoded.protected) sign.protected = toBase64url(encoded.protected)\r\n  return sign\r\n}\r\n\r\nfunction decode(encoded: EncodedJWS): DagJWS {\r\n  const decoded: DagJWS = {\r\n    payload: toBase64url(encoded.payload),\r\n    signatures: encoded.signatures.map(decodeSignature),\r\n  }\r\n  decoded.link = CID.decode(new Uint8Array(encoded.payload))\r\n  return decoded\r\n}\r\n\r\nexport default {\r\n  fromSplit,\r\n  encode,\r\n  decode,\r\n}\r\n"]},"metadata":{},"sourceType":"script"}